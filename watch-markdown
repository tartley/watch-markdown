#!/usr/bin/env bash

# Usage: watch-markdown <Markdown-file>
#
# Convert <markdown-file> to an HTML file. Open the HTML in Falkon, which has
# the nice property that if the HTML is subsequently modified, it auto-updates.
# Watch for modifications to the Markdown file. If any occur, regenerate the
# HTML file.

# TODO: Also handle rst->html. (Which presumably pandoc handles too.)
#
# TODO: Also handle a conversion for which we need a different viewer app.
#
# TODO: Let user add config for any combo of:
#   * command to convert source (eg Markdown) to target (eg HTML) file, and
#   * viewer (eg browser) for target file (eg HTML)
#
# TODO: Package up for end user installs. As a snap?

set -eu # errors terminate the script. Unset variables are errors.
# set -x # print debugging output of every executed command

if [ "$#" -eq 0 ]; then
    echo "watch-markdown: ERROR: No markdown filename given" >&2
    exit 1
fi
if [ "$#" -gt 1 ]; then
    echo "watch-markdown: ERROR: More than one markdown filename given" >&2
    exit 1
fi

in="$1"

# Output to a tmp filename which is human-readably related to the full pathname
# of the input file it is derived from (but converting slashes to make a valid
# filename)
outdir='/tmp/watch-markdown'
mkdir -p "$outdir"
out="$outdir/$(realpath ${in%.md}.html | tr '/' '\\')"

# Exit if a file exists at our proposed output location. We infer this means
# another instance of watch-markdown is already running on the given input
# file, so anything else we might do to write to this output would be redundant
# and possibly harmful.
if [ -f "$out" ]; then
    echo "watch-markdown: ERROR: Output file already exists, is watch-markdown already running on this input? '$out'" >&2
    exit 2
fi

function convert {
    # Convert the given markdown file to an HTML file
    css="$HOME/.config/watch-markdown/github.css"
    pandoc --standalone -c "$css" "$in" -o "$out"
}

convert

# When we exit (ie when the html viewer below exits), kill our background processes.
function killjobs {
    # Silence expected 'no such process' errors when a terminal invocation of
    # watch-markdown is killed with Ctrl-C.
    jobs -p | xargs -i kill {} 2>&1 | grep -v "No such process" | :
    # Clean up our output file
    rm "$out" >&2
}
trap "killjobs" INT TERM EXIT

# Start a background process to watch for updates to the markdown. To do this,
# we need to run inotifywait on two event types:
#   1. close_write (as is done by things that directly modify the file)
#   2. moved_to (as is done by Emacs/Vi-style write-new-then-move-to-overwrite)
# After (2), a watch on the file will no longer work, since it has been replaced
# by a new, different file of the same name. Hence we need to set up a watch on
# the parent directory, and then filter the resulting events for the filename we
# are watching.
parentdir=$(dirname "$in")
inotifywait --quiet --monitor --event close_write,moved_to --format "%e/%f" $parentdir \
| while IFS=/ read -r events file; do
    # If the event is for the markdown file we are watching
    actual=$(realpath $parentdir/$file)
    expected=$(realpath $in)
    if [ "$actual" = "$expected" ]; then
        # Regenerate the HTML file again.
        convert
    fi
done &

# Open a window to view the generated HTML. We want a viewer that:
# * Runs synchronously, so that this script blocks here until it exits.
# * Re-renders automatically if the HTML file changes. Firefox & Chrome don't
#   do this, but Gnome Web (aka epiphany), or Falkon do.
# To avoid the confusing reinstatement of multiple old tabs, we open a
# --private-browsing session.
falkon --no-extensions --private-browsing "$out"

