#!/usr/bin/env bash

# Usage: watch-markdown <Markdown-file>
#
# Convert <markdown-file> to an HTML file. Open the HTML in Falkon, which has
# the nice property that if the HTML is subsequently modified, it auto-updates.
# Watch for modifications to the Markdown file. If any occur, regenerate the
# HTML file.

# TODO: Can we display our other error messages as notify-sends?
# TODO: Can we forward error responses from pandoc to notify-sends?
# TODO: Can we forward error responses from other 3rd party progs to notify-sends?
#
# TODO: Also handle rst->html. (Which presumably pandoc handles too.)
#
# TODO: Also handle a conversion for which we need a different viewer app.
#
# TODO: Let user add config for any combo of:
#   * command to convert source (eg Markdown) to target (eg HTML) file, and
#   * viewer (eg browser) for target file (eg HTML)
#
# TODO: Package up for end user installs. As a snap?

set -e # Errors terminate the script.
# set -u # Unset variables are errors.
# set -x # print debugging output of every executed command

function error {
    exitval="$1"
    title="$2"
    message="$3"
    # If we are connected to a terminal...
    if [ -t 1 ]; then
        # ...use it.
        echo "$title: $message" >&2
    else
        # Otherwise, use a system notification popup.
        # notify-send requires single backslashes to be doubled.
        notify-send "$title" "$(echo "$message" | sed 's/\\/\\\\/g')"
    fi
    exit "$1"
}

if [ "$#" -eq 0 ]; then
    error 1 "watch-markdown ERROR" "No markdown filename given"
fi
if [ "$#" -gt 1 ]; then
    error 1 "watch-markdown ERROR" "More than one markdown filename given"
fi

in="$1"

# Output to a file in /tmp. We want to use the existence of this file as a
# mutex, to prevent multiple instances running on the same input file. For ease
# of diagnosis, use a filename that is a human-readable transform of the input
# file's full pathname.
outdir='/tmp/watch-markdown'
mkdir -p "$outdir"
out="$outdir/$(realpath ${in%.md}.html | tr '/' '\\')"

# Exit if a file exists at our proposed output location. We infer this means
# another instance of watch-markdown is already running on the given input
# file, so anything else we might do to write to this output would be redundant
# and possibly harmful.
if [ -f "$out" ]; then
    error 2 "watch-markdown ERROR" "The output file already exists. Is watch-markdown already running on this input? If not, try deleting the output file: $out"
fi

function convert {
    # Convert the given markdown file to an HTML file
    css="$HOME/.config/watch-markdown/github.css"
    pandoc --standalone -c "$css" "$in" -o "$out"
}

convert

# When we exit (ie when the html viewer below exits), kill our background processes.
function killjobs {
    # Silence expected 'no such process' errors when a terminal invocation of
    # watch-markdown is killed with Ctrl-C.
    jobs -p | xargs -i kill {} 2>&1 | grep -v "No such process" | :
    # Clean up our output file
    rm -f "$out" >&2
}
trap "killjobs" INT TERM EXIT

# Start a background process to watch for updates to the markdown. To do this,
# we need to run inotifywait on two event types:
#   1. close_write (as is done by things that directly modify the file)
#   2. moved_to (as is done by Emacs/Vi-style write-new-then-move-to-overwrite)
# After (2), a watch on the file will no longer work, since it has been replaced
# by a new, different file of the same name. Hence we need to set up a watch on
# the parent directory, and then filter the resulting events for the filename we
# are watching.
parentdir=$(dirname "$in")
inotifywait --quiet --monitor --event close_write,moved_to --format "%e/%f" $parentdir \
| while IFS=/ read -r events file; do
    # If the event is for the markdown file we are watching
    actual=$(realpath $parentdir/$file)
    expected=$(realpath $in)
    if [ "$actual" = "$expected" ]; then
        # Regenerate the HTML file again.
        convert
    fi
done &

# Open a window to view the generated HTML. We want a viewer that:
# * Runs synchronously, so that this script blocks here until it exits.
# * Re-renders automatically if the HTML file changes. Firefox & Chrome don't
#   do this, but Gnome Web (aka epiphany), or Falkon do.
# To avoid the confusing reinstatement of multiple old tabs, we open a
# --private-browsing session.
falkon --no-extensions --private-browsing "$out"

