#!/usr/bin/env bash

# Usage: watch-markdown <Markdown-file>
#
# Convert <markdown-file> to an HTML file. In the background, watch for
# modifications to the Markdown file. If any occur, regenerate the HTML file.
# Open the HTML in Falkon, which has the nice property that if the HTML is
# subsequently modified, it auto-updates.
#
# This means you can double click a markdown file in the GUI, and get a window
# displaying the markdown rendered as HTML. As you edit the markdown in your
# favorite editor, each time you hit 'save', the rendered HTML automatically
# updates.

# TODO: Also handle rst->html. (Which presumably pandoc handles too.)
#
# TODO: Also handle a conversion for which we need a different viewer app.
#       dot -> svg?
#
# TODO: Let user add config for any combo of:
#   * command to convert source (eg Markdown) to target (eg HTML) file, and
#   * viewer (eg browser) for target file (eg HTML)
#
# TODO: Package up for end user installs. As a snap?

set -e # Errors terminate the script.
# set -u # Unset variables are errors.
# set -x # print debugging output of every executed command

function error {
    exitval="$1"
    message="$2"
    echo "$message" >&2
    exit "$exitval"
}

if [ "$#" -eq 0 ]; then
    error 1 "No filename given."
fi
if [ "$#" -gt 1 ]; then
    error 1 ">1 filenames given."
fi

in="$1"

# Output to a file in /tmp. For transparency, use a filename that is an
# easily human-readable transform of the input file's full pathname,
# after resolving all symlinks.
outdir='/tmp/watch-markdown'
mkdir -p "$outdir"
out="$outdir/$(realpath ${in%.md}.html | tr '/' '\\')"

# If another instance were already running on our input file, any writes we
# make to our output file would be redundant, and possibly harmful. The
# construction of $out above means that any two instances of watch-markdown
# which are running on the same underlying input file, no matter whether they
# were invoked using absolute or relative paths, or symlinks, will produce the
# same output filename. We can therefore use the existence of this output file
# as a mutex, to prevent multiple instances running on the same input file. So
# if our proposed output file already exists, we exit.
if [ -f "$out" ]; then
    error 2 "The output file already exists. Is watch-markdown already running on this input? If not, try deleting the output file: $out"
fi

function generate_html_file {
    # Convert the given markdown file to an HTML file
    css="$HOME/.config/watch-markdown/style.css"
    pandoc --standalone -c "$css" "$in" -o "$out"
}

generate_html_file

# Cleanup on exit (ie when the HTML viewer at the end of this script exits)
function cleanup {
    # Kill our child processes.
    # The 'grep' silences puzzling but apparently harmless 'no such process'
    # errors when a terminal invocation of watch-markdown is killed with
    # Ctrl-C.
    jobs -p | xargs -i kill {} 2>&1 | grep -v "No such process" | :
    # Clean up our output file
    rm -f "$out"
}
trap "cleanup" INT TERM EXIT

# Start a background process to watch for updates to the markdown. To do this,
# we need to run inotifywait on two event types:
#   1. close_write (as is done by things that directly modify the file)
#   2. moved_to (as is done by Emacs/Vi-style write-new-then-move-to-overwrite)
# After (2), a watch on the file will no longer work, since it has been replaced
# by a new, different file of the same name. Hence we need to set up a watch on
# the parent directory, and then filter the resulting events for the filename we
# are watching.
parentdir=$(dirname "$in")
inotifywait --quiet --monitor --event close_write,moved_to --format "%e/%f" $parentdir \
| while IFS=/ read -r events file; do
    # If the event is for the markdown file we are watching
    actual=$(realpath $parentdir/$file)
    expected=$(realpath $in)
    if [ "$actual" = "$expected" ]; then
        generate_html_file
    fi
done &

# Open a window to view the generated HTML. We want a viewer that:
# * Runs synchronously, so that this script blocks here until it exits.
# * Re-renders automatically if the HTML file changes. Firefox & Chrome don't
#   do this, but Gnome Web (aka epiphany), or Falkon do.
# To avoid the confusing reinstatement of multiple old tabs, we open a
# --private-browsing session.
falkon --no-extensions --private-browsing "$out"

